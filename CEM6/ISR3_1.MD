## virtualenv

 **Virtualenv** — это утилита, которая позволяет создавать изолированные виртуальные окружения для Python.
 
 Какую проблему решает virtualenv? По умолчанию pip устанавливает пакеты как бы глобально. Большую часть времени это работает нормально, особенно если пишите вы небольшие скрипты, не имеющие огромного количества зависимостей. Но если у вас в несколько больших проектов, в которых используется что-то тяжелое и ломающее обратную совместимость между релизами (мне пока что удавалось избегать подобных проблем, но не удивлюсь, если этим грешит, скажем, Django) такое поведение становится проблемой.

Так вот, virtualenv — это инструмент, позволяющий создавать виртуальные окружения с пакетами. Разные «песочницы» (согласитесь, напоминает sandbox’ы в Cabal) имеют разный набор пакетов разных версий. Работая над конкретным проектом, вы просто переключаетесь на подходящую песочницу, и проблема уходит. Заметьте, что в отличие от того, как это сделано в некоторых других языках программирования, одну и ту же песочницу можно смело использовать сразу в нескольких проектах. Плюс к этому уходит проблема засорения системы ненужными пакетами, так как песочницы можно легко создавать и удалять. Как я это вижу, программируя на Python в третьем тысячелетии, вообще все нужно делать через virtualenv!
 
Установка virtualenv и virtualenvwrapper, предоставляющего чуть более удобный интерфейс к virtualenv:

```
sudo pip3 install virtualenv virtualenvwrapper
```

В ~/.bashrc дописываем:

```
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
source /usr/bin/virtualenvwrapper.sh
```

Создаем новое окружение:

```
mkvirtualenv env-name
```

Находясь в одном из окружений, можно ставить пакеты через pip, как обычно:

```
pip3 install flask

```

Список зависимостей проекта, насколько я смог разобраться, принято сохранять в файл с именем requirements.txt:

```
pip3 freeze > requirements.txt
```

Этот подход позволяет одной командой установить все зависимости, необходимые проекту:

```
pip3 install -r requirements.txt
```

## pipfile

**Pipfile** предназначен для замены requirements.txt. Pipenv в настоящее время является эталонной реализацией использования Pipfile. Возможно когда то, сам pip сможет обработать эти файлы. Также стоит отметить, что Pipenv является официальным инструментом управления пакетами, рекомендованным самими разработчиками Python.

Синтаксис Pipfile – это TOML, где файл разделяется на разделы.
[dev-packages] для пакетов только для разработки, [packages] для минимально необходимых пакетов и [requires] для других требований, таких как конкретная версия Python и т.п.

Pipfile.lock - Этот файл включает детерминированные зависимости, с указанными точными требованиями для воспроизведения в виртуальной среды. Он содержит точные версии для пакетов и их хеши для более безопасной проверки

### Дополнительные функции Pipenv
Вы можете открыть установленный пакет в редакторе по умолчанию с помощью следующей команды:

```
pipenv open flask
```

Вы можете запустить команду в виртуальной среде без запуска оболочки:

```
 pipenv run <insert command here>
```
Проверить наличие уязвимостей безопасности (и требований PEP 508) в вашей среде:

```
$ pipenv check
```

Теперь, допустим, вам больше не нужен пакет. Вы можете удалить его командой:

```
$ pipenv uninstall numpy
```

Кроме того, допустим, вы хотите полностью стереть все установленные пакеты из вашей виртуальной среды:

```
pipenv uninstall --all
```


## pipenv

**Pipenv** – это набирающий популярность пакет управления виртуальным окружением для Python, который решает некоторые распространенные проблемы, связанные с типичным рабочим процессом, в котором используется pip, virtualenv и старый добрый файл requirements.txt.

### Какие проблемы решает Pipenv?
Для того чтобы понять преимущества Pipenv, нужно изучить текущие методы работы с пакетами и управления зависимостями в Python.

Давайте начнем с типичной ситуации в работе со сторонними пакетами. Затем мы рассмотрим пример развертывания приложения Python.

Устанвка:

```
$ pip install pipenv
```

Пример использования:

```
$ pipenv shell
```

