## virtualenv

 **Virtualenv** — это утилита, которая позволяет создавать изолированные виртуальные окружения для Python.
 
 Какую проблему решает virtualenv? По умолчанию pip устанавливает пакеты как бы глобально. Большую часть времени это работает нормально, особенно если пишите вы небольшие скрипты, не имеющие огромного количества зависимостей. Но если у вас в несколько больших проектов, в которых используется что-то тяжелое и ломающее обратную совместимость между релизами (мне пока что удавалось избегать подобных проблем, но не удивлюсь, если этим грешит, скажем, Django) такое поведение становится проблемой.

Так вот, virtualenv — это инструмент, позволяющий создавать виртуальные окружения с пакетами. Разные «песочницы» (согласитесь, напоминает sandbox’ы в Cabal) имеют разный набор пакетов разных версий. Работая над конкретным проектом, вы просто переключаетесь на подходящую песочницу, и проблема уходит. Заметьте, что в отличие от того, как это сделано в некоторых других языках программирования, одну и ту же песочницу можно смело использовать сразу в нескольких проектах. Плюс к этому уходит проблема засорения системы ненужными пакетами, так как песочницы можно легко создавать и удалять. Как я это вижу, программируя на Python в третьем тысячелетии, вообще все нужно делать через virtualenv!
 
Установка virtualenv и virtualenvwrapper, предоставляющего чуть более удобный интерфейс к virtualenv:

```
sudo pip3 install virtualenv virtualenvwrapper
```

В ~/.bashrc дописываем:

```
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
source /usr/bin/virtualenvwrapper.sh
```

Создаем новое окружение:

```
mkvirtualenv env-name
```

Находясь в одном из окружений, можно ставить пакеты через pip, как обычно:

```
pip3 install flask

```

Список зависимостей проекта, насколько я смог разобраться, принято сохранять в файл с именем requirements.txt:

```
pip3 freeze > requirements.txt
```

Этот подход позволяет одной командой установить все зависимости, необходимые проекту:

```
pip3 install -r requirements.txt
```

## pipfile

**Pipfile** предназначен для замены requirements.txt. Pipenv в настоящее время является эталонной реализацией использования Pipfile. Возможно когда то, сам pip сможет обработать эти файлы. Также стоит отметить, что Pipenv является официальным инструментом управления пакетами, рекомендованным самими разработчиками Python.

Синтаксис Pipfile – это TOML, где файл разделяется на разделы.
[dev-packages] для пакетов только для разработки, [packages] для минимально необходимых пакетов и [requires] для других требований, таких как конкретная версия Python и т.п.

Pipfile.lock - Этот файл включает детерминированные зависимости, с указанными точными требованиями для воспроизведения в виртуальной среды. Он содержит точные версии для пакетов и их хеши для более безопасной проверки

### Дополнительные функции Pipenv
Вы можете открыть установленный пакет в редакторе по умолчанию с помощью следующей команды:

```
pipenv open flask
```

Вы можете запустить команду в виртуальной среде без запуска оболочки:

```
 pipenv run <insert command here>
```
Проверить наличие уязвимостей безопасности (и требований PEP 508) в вашей среде:

```
$ pipenv check
```

Теперь, допустим, вам больше не нужен пакет. Вы можете удалить его командой:

```
$ pipenv uninstall numpy
```

Кроме того, допустим, вы хотите полностью стереть все установленные пакеты из вашей виртуальной среды:

```
pipenv uninstall --all
```


## pipenv

**Pyenv** - это простой, мощный и кроссплатформенный инструмент для управления несколькими версиями Python в Linux-системах, он используется для:

* переключения глобальной версии Python для каждого пользователя;
* установки локальной версии Python для каждого проекта;
* управления виртуальными средами, созданными anaconda или virtualenv;
* переопределения версии Python с переменной окружения;
* поиска команд из нескольких версий Python и для многого другого.

## Как работает pyenv?

Как правило, версия Python по умолчанию используется для запуска всех ваших приложений, если вы явно не укажете версию, которую хотите использовать в приложении. Но pyenv реализует простую концепцию использования прокладок (легкие исполняемые файлы), чтобы передать вашу команду правильной версии Python, которую вы хотите использовать, когда у вас установлено несколько версий.

Эти прокладки вставлены pyenv в каталоги перед вашим PATH. Поэтому, когда вы запускаете команду Python, она перехватывается соответствующей прокладкой и передается в pyenv, который затем задает версию Python, указанную вашим приложением, и передает ваши команды правильной версии Python.


Установка:

```
$ pip install pipenv
```

Пример использования:

```
$ pipenv shell
```

## pyenv

Данный скрипт ни что иное как удобный менеджер версий для языка программирования Python. Лучше всего сразу всё увидеть на конкретных примерах.

Установка
Pyenv можно установить либо вручную, либо используя автоматический скрипт от того же автора. Я буду использовать автоматическую установку.

```
$ curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash
```

После этого появится сообщение о том, что необходимо добавить следующие строки кода в .profile / .bash_profile для того, чтобы автоматически обнаруживать pyenv.

```
export PATH="$HOME/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"
```

Инструмент располагается в ~/.pyenv/, а все версии будущих интерпретаторов Python будут находиться ~/.pyenv/versions/.
Перед тем как устанавливать определённую версию Python, необходимо предварительно поставить зависимости:

```
$ sudo apt-get install build-essential
$ sudo apt-get install python-dev libreadline-dev libbz2-dev libssl-dev libsqlite3-dev libxslt1-dev libxml2-dev
$ sudo apt-get install git
```

Для того чтобы установить определённую версию Питона необходимо выполнить следующую команду:
```
$ pyenv install 2.7.11
```

Для просмотра всех установленных версий Питона необходимо:

```
$ pyenv versions
```

Дополнительные опции для компиляции Python интерпретатора передаются через переменную окружения, например вот так:

```
PYTHON_CONFIGURE_OPTS="--enable-unicode=ucs4"
```

## VENV

### Как он работает? 

Основное отличие venv в том, что он встроен в интерпретатор и может отрабатывать ещё до загрузки системных модулей. Для этого, при определении базовой директории с библиотеками, используется примерно такой алгоритм:
* в директории с интерпретатором или уровнем выше ищется файл с именем pyvenv.cfg;
* если файл найден, в нём ищется ключ home, значение которого и будет базовой директорией;
* в базовой директории идёт поиск системной библиотеки (по спец. маркеру os.py);
* если что-то пошло не так – всё откатывается к захардкоженному в бинарнике значению.

### Как создать?

Нужно вызвать через ключ -m модуль venv, либо использовать встроенный скрипт pyvenv:
```
pyvenv /path/to/new/venv
```

Скрипт создаст указанную директорию, вместе со всеми родительскими директориями, если потребуется, и построит виртуальное окружение. Это можно делать и в Windows, только вызов будет чуть более многословным:
```
c:\Python33\python -m venv /path/to/new/venv
```

При создании можно добавлять различные параметры, как, например, включение системных site-packages или использование symlink вместо копирования интерпретатора.



### Как использовать?

Можно использовать старый добрый метод активации через bin/activate (Scripts/activate в windows):
```
cd /path/to/new/venv
. bin/activate
python3 some_script.py
```

А можно и не использовать, достаточно лишь вызвать интерпретатор из окружения и всё сработает автоматически:
```
/path/to/new/venv/bin/python3 some_script.py
```

Это конечно не сработает для скриптов, запускаемых напрямую через #!/usr/bin/env python3, для них всё равно нужно будет, как и раньше, делать активацию. Решение есть – о нём чуть ниже.

Обновление

Если в вашей системе обновилась версия python, то виртуальное окружение иногда тоже нужно обновить.
Всё просто – вызываем venv аналогично созданию окружения, добавив ключ --upgrade:
```
pyvenv --upgrade /path/to/new/venv
```

Это произойдёт автоматически, если использовать symlink, но если вы хотите кроме изоляции делать фиксацию версии python и библиотек, я бы рекомендовал делать обновление вручную.
