## Декоратор (шаблон проектирования)

**Декоратор** (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

## Задача
Объект, который предполагается использовать, выполняет основные функции. Однако может потребоваться добавить к нему некоторую дополнительную функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта.

## Способ решения 
Декоратор предусматривает расширение функциональности объекта без определения подклассов.

## Участники
Класс ConcreteComponent — класс, в который с помощью шаблона Декоратор добавляется новая функциональность. В некоторых случаях базовая функциональность предоставляется классами, производными от класса ConcreteComponent. В подобных случаях класс ConcreteComponent является уже не конкретным, а абстрактным. Абстрактный класс Component определяет интерфейс для использования всех этих классов.

## Следствия
1. Добавляемая функциональность реализуется в небольших объектах. Преимущество состоит в возможности динамически добавлять эту функциональность до или после основной функциональности объекта ConcreteComponent.
2. Позволяет избегать перегрузки функциональными классами на верхних уровнях иерархии
3. Декоратор и его компоненты не являются идентичными

## Реализация

Создаётся абстрактный класс, представляющий как исходный класс, так и новые, добавляемые в класс функции. В классах-декораторах новые функции вызываются в требуемой последовательности — до или после вызова последующего объекта.

При желании остаётся возможность использовать исходный класс (без расширения функциональности), если на его объект сохранилась ссылка.

## Приминение щаблона 

Драйверы-фильтры в ядре Windows (архитектура WDM (Windows Driver Model)) представляют собой декораторы. Несмотря на то, что WDM реализована на не-объектном языке Си, в ней чётко прослеживаются паттерны проектирования — декоратор, цепочка обязанностей, и команда (объект IRP).

Архитектура COM (Component Object Model) не поддерживает наследование реализаций, вместо него предлагается использовать декораторы (в данной архитектуре это называется «агрегация»). При этом архитектура решает (с помощью механизма pUnkOuter) проблему object identity, возникающую при использовании декораторов — identity агрегата есть identity его самого внешнего декоратора.

## Пример реализации на языке программирования python

```python
from abc import ABCMeta, abstractmethod

class IOperator(object):
    """
    Интерфейс, который должны реализовать как декоратор,
    так и оборачиваемый объект.
    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def operator(self):
        pass


class Component(IOperator):
    """Компонент программы"""
    def operator(self):
        return 10.0


class Wrapper(IOperator):
    """Декоратор"""
    def __init__(self, obj):
        self.obj = obj

    def operator(self):
        return self.obj.operator() + 5.0


comp = Component()
comp = Wrapper(comp)
print comp.operator()
# 15.0
```
